export const meta = {
  title: 'Agentic workflow with worktrees',
  subtitle: 'Running multiple agents at the same time',
  date: '2026-02-24',
  badges: [
    {
      text: 'Tooling',
      color: 'blue',
    }
  ]
}

## Contents

## Introduction

For past few months my workflow has been heavily relying on working with coding agents. The big shift happened in December where I really took Opus 4.5 through its paces and spend a lot of time with it. This was the time when it clicked for me - it fundamentally changed how I work with code.

I'm still not sold on vibecoding though, I'm reviewing all the code my agent is writing and I think you should too. I often find that either they are taking A LOT of shortcuts or overengineering things (especially codex ü´†). You really have to spend a lot of time to talk through the plan with the agent - and for that deep technical knowledge is required.

In this quick blog post I want to outline how I use worktrees to orchestrate multiple agents in the same repository. 

## Why worktrees

I know there is a big split in the community on this. People are either doing full separate git checkouts (as the author of OpenClaw, [Peter Steinberger](https://x.com/steipete)) or relying on the built-in feature of git to achieve it - worktrees.

I agree with the first party that using the plain git commands for worktrees might be a bit rough, but I solved it with help of a tool called [worktrunk](https://worktrunk.dev) which I think is how the API of git worktrees should be from the start. 


## My setup

Core of my workflow starts with `tmux`, it helps me manage terminal sessions, windows and splits. Most of the time in each of my tmux panes sits [OpenCode](https://opencode.ai). I also sometimes use [Claude Code](https://claude.com/product/claude-code) or [Codex](https://openai.com/codex/) but my favourite is OpenCode - it has the best UI and UX, I also love to try out different models and OpenCode is the best for that.

As I mentioned in the previous section, the core of my workflow relies on [worktrunk](https://worktrunk.dev). You can install it on macOS using homebrew: 

```bash
brew install worktrunk && wt config shell install
```

The way I work with AI requires a lot of back and fourth on the plan before the agent starts execution. To be a bit faster I often rely on dictation instead of typing, for that I use [Handy üñêÔ∏è](https://handy.computer) which runs a local model for dictation. Lately I've been working a lot with GPT-5.3 Codex which does a lot of research to compose plans - and this is a perfect place were we can parallel multiple workers to work on features faster.

When working on a new feature I create a new worktree by running:

```bash
wt switch <branch_name> --create
```

It then automatically copies my `.env` and `node_modules` thanks to this line in my `.config/woktrunk/config.yml`:

```yml
[post-create]
copy = "wt step copy-ignored"
```

Then I pop into OpenCode and switch to Plan mode. I have custom skills for how I like my plans to be structured (you can check them out here). Once I give the agent all my context and let him work on the plan, I'll spin up a second one by running the same command as above and go back and fourth between them. I found that working with around 3 of them at the same time is the sweet spot for me. I know a people are bragging on X how they manage 10 or 15 agents at the same time but I found it was too much context switching for me.

After a feature is finished I have a custom OpenCode command `/ship` that is pretty self explanatory - it uses my commit and PR skills to open a pull request for GitHub.

One last command to run is to remove the worktree from your computer:

```bash
wt remove <branch_name>
```

Pretty easy right? üòÖ


## That's a wrap

Thanks for reading! I hope you found this article useful. If you have any questions or feedback feel free to reach out to me on¬†[Twitter](https://twitter.com/o_kwasniewski).
